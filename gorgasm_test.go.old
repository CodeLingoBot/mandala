package gorgasm

import (
	"github.com/remogatto/application"
	"github.com/remogatto/egl"
	"github.com/remogatto/egl/platform"
	"github.com/remogatto/prettytest"
	"testing"
)

type testSuite struct {
	prettytest.Suite
	pauseTest    chan bool
	eglStateTest chan bool
	renderTest   chan bool
	draw         chan func()
	running      bool
}

func draw() {
	// draw something
}

func (t *testSuite) BeforeAll() {
	go func() {
		go application.Run()
		for {
			select {}
		}
	}()

	t.pauseTest = make(chan bool)
	t.eglStateTest = make(chan bool)
	t.renderTest = make(chan bool)
	t.draw = make(chan func())

	// Initialize the EGL surface, should be non-blocking.
	go func() {
		initialize <- platform.EGLState{Surface: 0xdeadbeef}
	}()

	// Start client loops

	t.running = true

	// Events
	go func() {
		for t.running {
			select {
			case untypedEvent := <-Events:
				switch untypedEvent.(type) {
				case PauseEvent:
					t.pauseTest <- true
				}
			}
		}
	}()

	// Rendering
	go func() {
		for t.running {
			select {
			case drawFunc := <-t.draw:
				Render <- drawFunc
				t.renderTest <- true
			}
		}
	}()

}

func (t *testSuite) TestEGLStateRequest() {
	eglStateCh := make(chan platform.EGLState)
	request := EGLStateRequest{eglStateCh}
	RenderLoop.Request <- request
	t.Equal(egl.Surface(0xdeadbeef), (<-eglStateCh).Surface)
}

func (t *testSuite) TestPauseEvent() {
	event <- PauseEvent{}
	t.True(<-t.pauseTest)
}

func (t *testSuite) TestRender() {
	t.draw <- draw
	t.True(<-t.renderTest)
}

func TestGorgasm(t *testing.T) {
	prettytest.Run(t, new(testSuite))
}
